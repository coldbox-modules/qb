

<!DOCTYPE html>
<html lang="en">
<head>
	<title>Builder</title>
	<meta name="keywords" content="qb.models.Query.concurrent.Callable interface">
	<!-- common assets -->
	

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel ="stylesheet" type="text/css" href="../../../bootstrap/css/bootstrap.min.css">
<link rel ="stylesheet" type="text/css" href="../../../stylesheet.css">
	
<link href='https://fonts.googleapis.com/css?family=Ubuntu:400,300,300italic,400italic,700,700italic|Ubuntu+Mono' rel='stylesheet' type='text/css' />
	
<script src="../../../bootstrap/js/jquery-2.1.0.min.js" type="text/javascript"></script>
<script src="../../../bootstrap/js/bootstrap.min.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
	// Global Tool Tip Settings
	$( '[title]' ).tooltip({
		 animation: 'slide',
		 delay: { show: 250, hide: 250 }
	});
});
</script>
	<!-- syntax highlighter -->
	<link type="text/css" rel="stylesheet" href="../../../highlighter/styles/shCoreDefault.css">
	<script src="../../../highlighter/scripts/shCore.js"></script>
	<script src="../../../highlighter/scripts/shBrushColdFusion.js"></script>
	<script src="../../../highlighter/scripts/shBrushXml.js"></script>
	<script src="../../../highlighter/scripts/shBrushSql.js"></script>
	<script src="../../../highlighter/scripts/shBrushJScript.js"></script>
	<script src="../../../highlighter/scripts/shBrushJava.js"></script>
	<script src="../../../highlighter/scripts/shBrushCss.js"></script>
	<script type="text/javascript">SyntaxHighlighter.all();</script>
</head>

<body class="withNavbar">






<!-- ========= START OF NAVBAR ======= -->
<a name="navbar_top"></a>
<a href="#skip-navbar_top" title="skip navigation links"></a>	

<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container-fluid">
    
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#class-navigation">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="#"><strong>qb</strong></a>
		</div>

	    <div class="collapse navbar-collapse" id="class-navigation">
	    	<ul class="nav navbar-nav">
				
					
					<li><a href="../../../overview-summary.html"><i class="glyphicon glyphicon-plane"></i> overview</a></li>
					
				

				
					<li><a href="package-summary.html"><i class="glyphicon glyphicon-folder-open"></i> &nbsp;package</a></li>
				

			  	
					<li class="dropdown active">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown"><i class="glyphicon glyphicon-file"></i> class <b class="caret"></b></a>

						<ul class="dropdown-menu">
							<li><a href="#class">Class Definition</a></li>
							<li><a href="#constructor_summary">Constructor Summary</a></li>
							<li><a href="#constructor_detail">Constructor Detail</a></li>
							<li><a href="#inherited_methods">Inherited Methods</a></li>
							<li><a href="#method_summary">Method Summary</a></li>
							<li><a href="#method_detail">Method Detail</a></li>
							<li><a href="#property_summary">Property Summary</a></li>
							<li><a href="#property_detail">Property Detail</a></li>
							
						</ul>
					</li>
				
	      	</ul>

			<ul class="nav navbar-nav navbar-right">
				<li><a href="../../../index.html?qb/models/Query/Builder.html" target="_top">
					<i class="glyphicon glyphicon-fullscreen"></i> Frames
					</a>
				</li>
			</ul>
	    </div>

	</div>
</nav>	

<a name="skip-navbar_top"></a>
<!-- ========= END OF NAVBAR ========= -->

<!-- ======== start of class data ======== -->
<a name="class"><!-- --></a>

<!-- Package -->
<div class="pull-right">
	<a href="package-summary.html" title="Package: qb.models.Query"><span class="label label-success">qb.models.Query</span></a>
</div>

<h2>


Class

 Builder</h2>








	
		
	
	

	
		
		
			
		
	
	


<!-- Inheritance Tree-->
<pre style="background:white">lucee.Component
    <img src="../../../resources/inherit.gif" alt="extended by ">qb.models.Query.Builder
</pre>



	
	



<div class="panel panel-default">
	<div class="panel-heading"><strong>Direct Known Subclasses:</strong></div>
  	<div class="panel-body">
	
		
		<a href="../../../qb/models/Query/JoinClause.html" title="class in qb.models.Query">JoinClause</a>
	
	</div>
</div>





<div id="class-hint">
	<p>Query Builder for fluently creating SQL queries.</p>
</div>


<!-- Clas Attributes -->
<div class="panel panel-info">
	<div class="panel-heading"><strong>Class Attributes:</strong></div>
		<div class="panel-body">
		
		
			
		
			
		
			
		
			
			
			<li class="label label-danger label-annotations">
				displayname 
				
				: Builder		
				
			</li>
			&nbsp;
			
		
			
			
			<li class="label label-danger label-annotations">
				synchronized 
				
				: false		
				
			</li>
			&nbsp;
			
		
			
		
			
		
			
		
			
		
			
			
			<li class="label label-danger label-annotations">
				accessors 
				
				: true		
				
			</li>
			&nbsp;
			
		
			
		
			
			
			<li class="label label-danger label-annotations">
				persistent 
				
				: false		
				
			</li>
			&nbsp;
			
		
			
		
			
		
		
	</div>
</div>




<!-- ========== METHOD SUMMARY =========== -->

<a name="property_summary"><!-- --></a>
<table class="table table-bordered table-hover">
	<tr class="info">
		<th align="left" colspan="5">
			<strong>Property Summary</strong>
		</th>
	</tr>
	<tr class="info">
		<th align="left">
			<strong>type</strong>
		</th>
		<th align="left">
			<strong>property</strong>
		</th>
		<th align="left">
			<strong>default</strong>
		</th>
		<th align="left">
			<strong>serializable</strong>
		</th>
		<th align="left">
			<strong>required</strong>
		</th>
	</tr>

	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>struct</code>
		</td>
		<td>
			<strong><a href="Builder.html#aggregate()">aggregate</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The aggregate option and column to execute.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#columns()">columns</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An array of columns to select.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>boolean</code>
		</td>
		<td>
			<strong><a href="Builder.html#distinct()">distinct</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flag to bring back only distinct values.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#from()">from</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The base table of the query.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#grammar()">grammar</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The specific grammar that will compile the builder statements.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#groups()">groups</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An array of GROUP BY statements.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#havings()">havings</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An array of HAVING statements.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#joins()">joins</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An array of JOIN statements.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>numeric</code>
		</td>
		<td>
			<strong><a href="Builder.html#limitValue()">limitValue</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The LIMIT value, if any.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>numeric</code>
		</td>
		<td>
			<strong><a href="Builder.html#offsetValue()">offsetValue</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The OFFSET value, if any.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#orders()">orders</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An array of ORDER BY statements.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#returnFormat()">returnFormat</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnFormat callback.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#utils()">utils</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Query utilities shared across multiple models.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#wheres()">wheres</A></strong> 
			<br>
			
			<!-- only grab the first sentence of the hint -->
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An array of WHERE statements.
			
			<br><br>
			<ul>
			
				
			
				
				<li class="label label-default label-annotations">access = public</li>
				
			
				
			
				
			
				
				<li class="label label-default label-annotations">returntype = any</li>
				
			
				
			
				
			
				
			
			</ul>

		</td>
		<td align="right" valign="top" width="1%">
			
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				true
			</code>
		</td>
		<td align="right" valign="top" width="1%">
			<code>
				false
			</code>
		</td>
	</tr>
	
	</tr>
</table>



	
	
	<!-- ======== CONSTRUCTOR SUMMARY ======== -->

	<a name="constructor_summary"><!-- --></a>
	<table class="table table-bordered table-hover">
		<tr class="info">
			<th align="left" colspan="2">
				<strong>Constructor Summary</strong>
			</th>
		</tr>
		<tr>
			
			<td>
				<strong><a href="Builder.html#init()">init</A></strong>([qb.models.Query.grammar grammar='[runtime expression]'], [<a href="../../../qb/models/Query/QueryUtils.html" title="class in qb.models.Query">QueryUtils</a> utils='[runtime expression]'], [any returnFormat='array'])
				<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Creates an empty query builder.
				
			</td>
		</tr>
	</table>





<!-- ========== METHOD SUMMARY =========== -->

<a name="method_summary"><!-- --></a>
<table class="table table-bordered table-hover">
	<tr class="info">
		<th align="left" colspan="2">
			<strong>Method Summary</strong>
		</th>
	</tr>

	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#addBindings()">addBindings</A></strong>(any newBindings, [string type='where'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a single binding or an array of bindings to a query for a given type.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#addNestedWhereQuery()">addNestedWhereQuery</A></strong>(<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> query, [string combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the bindings for a nested WHERE statment to the current query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#addSelect()">addSelect</A></strong>(any columns)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a selection of columns to the already selected columns.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#addWhereExistsQuery()">addWhereExistsQuery</A></strong>([any query], [any combinator='and'], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE EXISTS clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;any</code>
		</td>
		<td>
			<strong><a href="Builder.html#aggregateQuery()">aggregateQuery</A></strong>(string type, string column='*', [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform an aggregate function on a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#clearBindings()">clearBindings</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear all the bindings on the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>numeric</code>
		</td>
		<td>
			<strong><a href="Builder.html#count()">count</A></strong>([string column='*'], [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a count from a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#crossJoin()">crossJoin</A></strong>(string table, [any first], [string operator], [any second])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a CROSS JOIN to another table.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#delete()">delete</A></strong>([any id], [string idColumnName='id'], [struct options='[runtime expression]'], [boolean toSql='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes a record set.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#distinct()">distinct</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the DISTINCT flag for the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>boolean</code>
		</td>
		<td>
			<strong><a href="Builder.html#exists()">exists</A></strong>([struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the query returns any rows.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#find()">find</A></strong>(any id, [string idColumn='id'], [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an id constraint to the query and returns the first record from the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#first()">first</A></strong>([struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first record returned from a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#forNestedWhere()">forNestedWhere</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new query scoped to the same table as the current query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#forPage()">forPage</A></strong>(numeric pageNumber, numeric pageCount)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method to calculate the limit and offset given a page number and count per page.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#from()">from</A></strong>(string from)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the FROM table of the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#get()">get</A></strong>([any columns], [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runs the current select query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getAggregate()">getAggregate</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#getBindings()">getBindings</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a flat array of bindings.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getColumns()">getColumns</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getDistinct()">getDistinct</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getFrom()">getFrom</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getGrammar()">getGrammar</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getGroups()">getGroups</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getHavings()">getHavings</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getJoins()">getJoins</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getLimitValue()">getLimitValue</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getOffsetValue()">getOffsetValue</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getOrders()">getOrders</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>struct</code>
		</td>
		<td>
			<strong><a href="Builder.html#getRawBindings()">getRawBindings</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all the binding types and their associated bindings.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getReturnFormat()">getReturnFormat</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getUtils()">getUtils</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#getWheres()">getWheres</A></strong>()
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#groupBy()">groupBy</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a group by clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#having()">having</A></strong>([any column], [any operator], [any value], [string combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a having clause to a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#implode()">implode</A></strong>(string column, [string glue=''], [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all the values of a column in a query and return it as a single string glued together.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#insert()">insert</A></strong>(any values, [struct options='[runtime expression]'], [boolean toSql='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts a single struct or an array of structs in to a table.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;boolean</code>
		</td>
		<td>
			<strong><a href="Builder.html#isInvalidCombinator()">isInvalidCombinator</A></strong>(string combinator)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a combinator is an invalid sql combinator (according to qb).
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;boolean</code>
		</td>
		<td>
			<strong><a href="Builder.html#isInvalidOperator()">isInvalidOperator</A></strong>(string operator)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if an operator is an invalid sql operator (according to qb).
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;boolean</code>
		</td>
		<td>
			<strong><a href="Builder.html#isVariadicFunction()">isVariadicFunction</A></strong>(struct args)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the arguments passed constitute a variadic function.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#join()">join</A></strong>(string table, any first, [string operator='='], [string second], [string type='inner'], [boolean where='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an INNER JOIN to another table.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#joinWhere()">joinWhere</A></strong>(string table, any first, [string operator], [string second], [string type='inner'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a JOIN to another table based on a `WHERE` clause instead of an `ON` clause.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#leftJoin()">leftJoin</A></strong>(string table, [string first], [string operator], [string second], [boolean where])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a LEFT JOIN to another table.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#limit()">limit</A></strong>(numeric value)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the limit value for the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#max()">max</A></strong>(string column, [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the max of a column from a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#min()">min</A></strong>(string column, [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the min of a column from a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#newQuery()">newQuery</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new query using the same Grammar and QueryUtils.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;array</code>
		</td>
		<td>
			<strong><a href="Builder.html#normalizeListArgumentsToArray()">normalizeListArgumentsToArray</A></strong>(string list)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a list of arguments to an array.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;array</code>
		</td>
		<td>
			<strong><a href="Builder.html#normalizeToArray()">normalizeToArray</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the arguments passed in to it into an array.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;array</code>
		</td>
		<td>
			<strong><a href="Builder.html#normalizeVariadicArgumentsToArray()">normalizeVariadicArgumentsToArray</A></strong>(struct args)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a variadic list of arguments to an array.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#offset()">offset</A></strong>(numeric value)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the offset value for the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#onMissingMethod()">onMissingMethod</A></strong>([string missingMethodName], [struct missingMethodArguments])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onMissingMethod serves the following purpose for Builder:.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orderBy()">orderBy</A></strong>(any column, [string direction='asc'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an order by clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhere()">orWhere</A></strong>([any column], [any operator], [any value])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an OR WHERE clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereBetween()">orWhereBetween</A></strong>([any column], [any start], [any end], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a OR WHERE BETWEEN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereColumn()">orWhereColumn</A></strong>(any first, [any operator], [any second])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a OR WHERE clause to the query comparing two columns.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereExists()">orWhereExists</A></strong>([any callback], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an OR WHERE EXISTS clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereIn()">orWhereIn</A></strong>([any column], [any values], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an OR WHERE IN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereNotBetween()">orWhereNotBetween</A></strong>([any column], [any start], [any end], [any combinator])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an OR WHERE NOT BETWEEN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereNotExists()">orWhereNotExists</A></strong>([any callback])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a OR WHERE NOT EXISTS clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereNotIn()">orWhereNotIn</A></strong>([any column], [any values])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an OR WHERE NOT IN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereNotNull()">orWhereNotNull</A></strong>([any column])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an OR WHERE NOT NULL clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereNull()">orWhereNull</A></strong>([any column], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an OR WHERE NULL clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#orWhereRaw()">orWhereRaw</A></strong>(string sql, [array whereBindings='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a raw SQL statement to the WHERE clauses with an OR combinator.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Expression.html" title="class in qb.models.Query">Expression</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#raw()">raw</A></strong>(string sql)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrap up any sql in an Expression.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#rightJoin()">rightJoin</A></strong>(string table, [string first], [string operator], [string second], [boolean where])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a RIGHT JOIN to another table.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;any</code>
		</td>
		<td>
			<strong><a href="Builder.html#run()">run</A></strong>(string sql, [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Execute a query and convert it to the proper return format.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;any</code>
		</td>
		<td>
			<strong><a href="Builder.html#runQuery()">runQuery</A></strong>(string sql, [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a query through the specified grammar then clear all bindings.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#select()">select</A></strong>([any columns='*'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a selection of columns to select from the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#selectRaw()">selectRaw</A></strong>(any expression)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a Expression to the already selected columns.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setAggregate()">setAggregate</A></strong>(struct aggregate)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setColumns()">setColumns</A></strong>(array columns)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;void</code>
		</td>
		<td>
			<strong><a href="Builder.html#setDefaultValues()">setDefaultValues</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets up the default values for a new builder instance.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setDistinct()">setDistinct</A></strong>(boolean distinct)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setFrom()">setFrom</A></strong>(string from)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setGrammar()">setGrammar</A></strong>(any grammar)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setGroups()">setGroups</A></strong>(array groups)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setHavings()">setHavings</A></strong>(array havings)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setJoins()">setJoins</A></strong>(array joins)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setLimitValue()">setLimitValue</A></strong>(numeric limitValue)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setOffsetValue()">setOffsetValue</A></strong>(numeric offsetValue)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setOrders()">setOrders</A></strong>(array orders)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#setReturnFormat()">setReturnFormat</A></strong>(any format)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the return format for the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setUtils()">setUtils</A></strong>(any utils)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#setWheres()">setWheres</A></strong>(array wheres)
			<br>
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#sum()">sum</A></strong>(string column, [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the sum of a column from a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#table()">table</A></strong>(string table)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the FROM table of the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#take()">take</A></strong>(numeric value)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the limit value for the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#tap()">tap</A></strong>(any callback)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tap takes a callback and calls that callback with a copy of the current query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>string</code>
		</td>
		<td>
			<strong><a href="Builder.html#toSQL()">toSQL</A></strong>()
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Builder compiled to grammar-specific sql.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#update()">update</A></strong>(struct values, [struct options='[runtime expression]'], [boolean toSql='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates a table with a struct of column and value pairs.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#updateOrInsert()">updateOrInsert</A></strong>(struct values, [struct options='[runtime expression]'], [boolean toSql='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the query returns any rows, updates the first result found.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>any</code>
		</td>
		<td>
			<strong><a href="Builder.html#value()">value</A></strong>(string column, [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first value of a column in a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>array</code>
		</td>
		<td>
			<strong><a href="Builder.html#values()">values</A></strong>(string column, [struct options='[runtime expression]'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array of values for a column in a query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#when()">when</A></strong>(boolean condition, [any onTrue], [any onFalse])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When is a useful helper method that introduces if / else control flow without breaking chainability.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#where()">where</A></strong>([any column], [any operator], [any value], [string combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereBetween()">whereBetween</A></strong>([any column], [any start], [any end], [any combinator='and'], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE BETWEEN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereColumn()">whereColumn</A></strong>(any first, [any operator], [any second], [string combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE clause to the query comparing two columns.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereExists()">whereExists</A></strong>([any callback], [any combinator='and'], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE EXISTS clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereIn()">whereIn</A></strong>([any column], [any values], [any combinator='and'], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE IN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereInSub()">whereInSub</A></strong>([any column], [any callback], [any combinator='and'], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE IN clause to the query using a subselect.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereNested()">whereNested</A></strong>(any callback, [any combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a nested where statement to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereNotBetween()">whereNotBetween</A></strong>([any column], [any start], [any end], [any combinator])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE NOT BETWEEN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereNotExists()">whereNotExists</A></strong>([any callback], [any combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE NOT EXISTS clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereNotIn()">whereNotIn</A></strong>([any column], [any values], [any combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE NOT IN clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereNotNull()">whereNotNull</A></strong>([any column], [any combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE NOT NULL clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereNull()">whereNull</A></strong>([any column], [any combinator='and'], [any negate='false'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a WHERE NULL clause to the query.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code><a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereRaw()">whereRaw</A></strong>(string sql, [array whereBindings='[runtime expression]'], [string combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a raw SQL statement to the WHERE clauses.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a></code>
		</td>
		<td>
			<strong><a href="Builder.html#whereSub()">whereSub</A></strong>([any column], [any operator], [any callback], [any combinator='and'])
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a where clause where the value is a subquery.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;any</code>
		</td>
		<td>
			<strong><a href="Builder.html#withAggregate()">withAggregate</A></strong>(struct aggregate, any callback)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runs the code inside the callback with the given aggregate in place and then sets the aggregate back to its original value.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;any</code>
		</td>
		<td>
			<strong><a href="Builder.html#withColumns()">withColumns</A></strong>(any columns, any callback)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runs the code inside the callback with the given columns selected and then sets the columns back to its original value.
			
		</td>
	</tr>
	
	
	
	<tr>
		<td align="right" valign="top" width="1%">
			<code>private&nbsp;any</code>
		</td>
		<td>
			<strong><a href="Builder.html#withReturnFormat()">withReturnFormat</A></strong>(any returnFormat, any callback)
			<br>
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runs the code inside the callback with the return format specified and then sets the return format back to its original value.
			
		</td>
	</tr>
	
</table>



<a name="inherited_methods"><!-- --></a>


	

	

	&nbsp;
	<a name="methods_inherited_from_class_lucee.Component"><!-- --></a>
	<table class="table table-hover table-bordered">
		<tr class="info">
			<th align="left">
				<strong>Methods inherited from class <kbd>lucee.Component</kbd></strong>
			</th>
		</tr>
		<tr>
			<td>
				
				
				
				
				
					<span class="label label-warning"><em>None</em></span>
				
			</td>
		</tr>
	</table>


<hr>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

	<a name="constructor_detail"><!-- --></a>
	<table class="table table-bordered">
		<tr class="info">
			<th colspan="1" align="left">
				<strong>Constructor Detail</strong>
			</th>
		</tr>
	</table>

	<a name="init()"><!-- --></a><h3>
	init</h3>
	<kbd>public <strong>init</strong>([qb.models.Query.grammar grammar='[runtime expression]'], [<a href="../../../qb/models/Query/QueryUtils.html" title="class in qb.models.Query">QueryUtils</a> utils='[runtime expression]'], [any returnFormat='array'])</kbd>

	<br><br>

	
	<p>Creates an empty query builder.</p>
	

	
	<dl>
		<dt><strong>Parameters:</strong></dt>
		
			<dd><code>grammar</code> - The grammar to use when compiling queries. Default: qb.models.Query.Grammars.Grammar</dd>
		
			<dd><code>utils</code> - A collection of query utilities. Default: qb.models.Query.QueryUtils</dd>
		
			<dd><code>returnFormat</code> - the closure (or string format shortcut) that modifies the query and is eventually returned to the caller. Default: 'array'</dd>
		
	</dl>
	
	<hr>


<!-- ============ PROPERTY DETAIL ========== -->

	<a name="property_detail"><!-- --></a>
	<table class="table table-bordered">
		<tr class="info">
			<th colspan="1" align="left">
				<strong>Property Detail</strong>
			</th>
		</tr>
	</table>

	
		
		<a name="aggregate()"><!-- --></a>
		<h3>aggregate</h3>

		<kbd>
			property struct 
			<strong>aggregate</strong>
			
		</kbd>

		<br><br>
		
			<p>The aggregate option and column to execute.
e.g. { type = "count", column = "*" }</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="columns()"><!-- --></a>
		<h3>columns</h3>

		<kbd>
			property array 
			<strong>columns</strong>
			
		</kbd>

		<br><br>
		
			<p>An array of columns to select.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="distinct()"><!-- --></a>
		<h3>distinct</h3>

		<kbd>
			property boolean 
			<strong>distinct</strong>
			
		</kbd>

		<br><br>
		
			<p>Flag to bring back only distinct values.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="from()"><!-- --></a>
		<h3>from</h3>

		<kbd>
			property string 
			<strong>from</strong>
			
		</kbd>

		<br><br>
		
			<p>The base table of the query.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="grammar()"><!-- --></a>
		<h3>grammar</h3>

		<kbd>
			property any 
			<strong>grammar</strong>
			
		</kbd>

		<br><br>
		
			<p>The specific grammar that will compile the builder statements.
e.g. MySQLGrammar, OracleGrammar, etc.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="groups()"><!-- --></a>
		<h3>groups</h3>

		<kbd>
			property array 
			<strong>groups</strong>
			
		</kbd>

		<br><br>
		
			<p>An array of GROUP BY statements.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="havings()"><!-- --></a>
		<h3>havings</h3>

		<kbd>
			property array 
			<strong>havings</strong>
			
		</kbd>

		<br><br>
		
			<p>An array of HAVING statements.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="joins()"><!-- --></a>
		<h3>joins</h3>

		<kbd>
			property array 
			<strong>joins</strong>
			
		</kbd>

		<br><br>
		
			<p>An array of JOIN statements.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="limitValue()"><!-- --></a>
		<h3>limitValue</h3>

		<kbd>
			property numeric 
			<strong>limitValue</strong>
			
		</kbd>

		<br><br>
		
			<p>The LIMIT value, if any.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="offsetValue()"><!-- --></a>
		<h3>offsetValue</h3>

		<kbd>
			property numeric 
			<strong>offsetValue</strong>
			
		</kbd>

		<br><br>
		
			<p>The OFFSET value, if any.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="orders()"><!-- --></a>
		<h3>orders</h3>

		<kbd>
			property array 
			<strong>orders</strong>
			
		</kbd>

		<br><br>
		
			<p>An array of ORDER BY statements.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="returnFormat()"><!-- --></a>
		<h3>returnFormat</h3>

		<kbd>
			property any 
			<strong>returnFormat</strong>
			
		</kbd>

		<br><br>
		
			<p>returnFormat callback
If provided, the result of the callback is returned as the result of builder.
Can optionally pass either "array" or "query"
and the correct callback will be generated</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="utils()"><!-- --></a>
		<h3>utils</h3>

		<kbd>
			property any 
			<strong>utils</strong>
			
		</kbd>

		<br><br>
		
			<p>Query utilities shared across multiple models.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	
		
		<a name="wheres()"><!-- --></a>
		<h3>wheres</h3>

		<kbd>
			property array 
			<strong>wheres</strong>
			
		</kbd>

		<br><br>
		
			<p>An array of WHERE statements.</p>
		

		<dl>
		<dt><strong>Attributes:</strong></dt>
		
			
		
			
			<dd><code>access</code> - public</dd>
			
		
			
			<dd><code>required</code> - false</dd>
			
		
			
		
			
			<dd><code>returntype</code> - any</dd>
			
		
			
		
			
		
			
			<dd><code>serializable</code> - true</dd>
			
		
		</dl>

		<hr>
	









<!-- ============ METHOD DETAIL ========== -->

<a name="method_detail"><!-- --></a>
<table class="table table-bordered">
	<tr class="info">
		<th colspan="1" align="left">
			<strong>Method Detail</strong>
		</th>
	</tr>
</table>


	
	<a name="addBindings()"><!-- --></a>
	<h3>addBindings</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>addBindings</strong>(any newBindings, [string type='where'])</kbd>
	
	<br><br>

	
		<p>Adds a single binding or an array of bindings to a query for a given type.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>newBindings</code> - A single binding or an array of bindings to add for a given type.</dd>
		
		<dd><code>type</code> - The type of binding to add.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="addNestedWhereQuery()"><!-- --></a>
	<h3>addNestedWhereQuery</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>addNestedWhereQuery</strong>(<a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> query, [string combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds the bindings for a nested WHERE statment to the current query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>query</code> - The query to add as a nested WHERE statement</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="addSelect()"><!-- --></a>
	<h3>addSelect</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>addSelect</strong>(any columns)</kbd>
	
	<br><br>

	
		<p>Adds a selection of columns to the already selected columns.
Individual columns can contain fully-qualified names (i.e. "some_table.some_column"),
fully-qualified names with table aliases (i.e. "alias.some_column"),
and even set column aliases themselves (i.e. "some_column AS c")
Each value will be wrapped correctly, according to the database grammar being used.
If no columns have been set, this column will overwrite the global "*".</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>columns</code> - A single column, a list or columns (comma-separated), or an array of columns.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="addWhereExistsQuery()"><!-- --></a>
	<h3>addWhereExistsQuery</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>addWhereExistsQuery</strong>([any query], [any combinator='and'], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE EXISTS clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>query</code> - The EXISTS query to add as a constraint.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		<dd><code>negate</code> - False for EXISTS, True for NOT EXISTS. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="aggregateQuery()"><!-- --></a>
	<h3>aggregateQuery</h3>
	
	<kbd>private any <strong>aggregateQuery</strong>(string type, string column='*', [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Perform an aggregate function on a query.
The original query is unaltered by this operation.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>type</code> - The aggregate type to execute.</dd>
		
		<dd><code>column</code> - The column on which to find the specified aggregate. Default: "*".</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="clearBindings()"><!-- --></a>
	<h3>clearBindings</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>clearBindings</strong>()</kbd>
	
	<br><br>

	
		<p>Clear all the bindings on the query.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="count()"><!-- --></a>
	<h3>count</h3>
	
	<kbd>public numeric <strong>count</strong>([string column='*'], [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Return a count from a query.
The original query is unaltered by this operation.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The column on which to count records. Default: "*".</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>numeric</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="crossJoin()"><!-- --></a>
	<h3>crossJoin</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>crossJoin</strong>(string table, [any first], [string operator], [any second])</kbd>
	
	<br><br>

	
		<p>Adds a CROSS JOIN to another table.
For simple joins, this joins one table to another in a cross join.
For complex joins, a closure can be passed to `first`.
This allows multiple `on` and `where` conditions to be applied to the join.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>table</code> - The table to join to the query.</dd>
		
		<dd><code>first</code> - The first column in the join's `on` statement. This alternatively can be a closure that will be passed a JoinClause for complex joins. Passing a closure ignores all subsequent parameters.</dd>
		
		<dd><code>operator</code> - The boolean operator for the join clause. Default: "=".</dd>
		
		<dd><code>second</code> - The second column in the join's `on` statement.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="delete()"><!-- --></a>
	<h3>delete</h3>
	
	<kbd>public any <strong>delete</strong>([any id], [string idColumnName='id'], [struct options='[runtime expression]'], [boolean toSql='false'])</kbd>
	
	<br><br>

	
		<p>Deletes a record set.
This call must come after setting the query's table using `from` or `table`.
Any constraining of the update query should be done using the appropriate WHERE statement before calling `update`.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>id</code> - A convience argument for `where( "id", "=", arguments.id ).  The query can be constrained by normal WHERE methods if you have more complex needs.</dd>
		
		<dd><code>idColumnName</code> - The name of the id column for the delete shorthand. Default: "id".</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		<dd><code>toSql</code> - If true, returns the raw sql string instead of running the query.  Useful for debugging. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="distinct()"><!-- --></a>
	<h3>distinct</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>distinct</strong>()</kbd>
	
	<br><br>

	
		<p>Sets the DISTINCT flag for the query.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="exists()"><!-- --></a>
	<h3>exists</h3>
	
	<kbd>public boolean <strong>exists</strong>([struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Returns true if the query returns any rows.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>boolean</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="find()"><!-- --></a>
	<h3>find</h3>
	
	<kbd>public any <strong>find</strong>(any id, [string idColumn='id'], [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Adds an id constraint to the query and returns the first record from the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>id</code> - The id value to look up.</dd>
		
		<dd><code>idColumn</code> - The name of the id column to constrain.  Default: "id".</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="first()"><!-- --></a>
	<h3>first</h3>
	
	<kbd>public any <strong>first</strong>([struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Returns the first record returned from a query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="forNestedWhere()"><!-- --></a>
	<h3>forNestedWhere</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>forNestedWhere</strong>()</kbd>
	
	<br><br>

	
		<p>Creates a new query scoped to the same table as the current query.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="forPage()"><!-- --></a>
	<h3>forPage</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>forPage</strong>(numeric pageNumber, numeric pageCount)</kbd>
	
	<br><br>

	
		<p>Helper method to calculate the limit and offset given a page number and count per page.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>pageNumber</code> - The page number to retrieve</dd>
		
		<dd><code>pageCount</code> - The number of records per page.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="from()"><!-- --></a>
	<h3>from</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>from</strong>(string from)</kbd>
	
	<br><br>

	
		<p>Sets the FROM table of the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>from</code> - The name of the table to from which the query is based.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="get()"><!-- --></a>
	<h3>get</h3>
	
	<kbd>public any <strong>get</strong>([any columns], [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Runs the current select query.
The selected columns before calling get will be restored after running the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>columns</code> - An optional column, list of columns, or array of columns to select.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="getAggregate()"><!-- --></a>
	<h3>getAggregate</h3>
	
	<kbd>public string <strong>getAggregate</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getBindings()"><!-- --></a>
	<h3>getBindings</h3>
	
	<kbd>public array <strong>getBindings</strong>()</kbd>
	
	<br><br>

	
		<p>Returns a flat array of bindings.  Used as the parameter list for `queryExecute`.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>array of bindings</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="getColumns()"><!-- --></a>
	<h3>getColumns</h3>
	
	<kbd>public string <strong>getColumns</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getDistinct()"><!-- --></a>
	<h3>getDistinct</h3>
	
	<kbd>public string <strong>getDistinct</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getFrom()"><!-- --></a>
	<h3>getFrom</h3>
	
	<kbd>public string <strong>getFrom</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getGrammar()"><!-- --></a>
	<h3>getGrammar</h3>
	
	<kbd>public string <strong>getGrammar</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getGroups()"><!-- --></a>
	<h3>getGroups</h3>
	
	<kbd>public string <strong>getGroups</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getHavings()"><!-- --></a>
	<h3>getHavings</h3>
	
	<kbd>public string <strong>getHavings</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getJoins()"><!-- --></a>
	<h3>getJoins</h3>
	
	<kbd>public string <strong>getJoins</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getLimitValue()"><!-- --></a>
	<h3>getLimitValue</h3>
	
	<kbd>public string <strong>getLimitValue</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getOffsetValue()"><!-- --></a>
	<h3>getOffsetValue</h3>
	
	<kbd>public string <strong>getOffsetValue</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getOrders()"><!-- --></a>
	<h3>getOrders</h3>
	
	<kbd>public string <strong>getOrders</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getRawBindings()"><!-- --></a>
	<h3>getRawBindings</h3>
	
	<kbd>public struct <strong>getRawBindings</strong>()</kbd>
	
	<br><br>

	
		<p>Returns all the binding types and their associated bindings.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>struct of binding types and their bindings</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="getReturnFormat()"><!-- --></a>
	<h3>getReturnFormat</h3>
	
	<kbd>public string <strong>getReturnFormat</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getUtils()"><!-- --></a>
	<h3>getUtils</h3>
	
	<kbd>public string <strong>getUtils</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="getWheres()"><!-- --></a>
	<h3>getWheres</h3>
	
	<kbd>public string <strong>getWheres</strong>()</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	

	

	</dl>
	<hr>

	
	<a name="groupBy()"><!-- --></a>
	<h3>groupBy</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>groupBy</strong>()</kbd>
	
	<br><br>

	
		<p>Add a group by clause to the query.
`groupBy` allows three ways to specify the grouping columns:
- a comma-separated list 
- an array
- variadic arguments
All the columns passed this way will be individually added to the query.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="having()"><!-- --></a>
	<h3>having</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>having</strong>([any column], [any operator], [any value], [string combinator='and'])</kbd>
	
	<br><br>

	
		<p>Add a having clause to a query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The column with which to constrain the having clause. An expression (`builder.raw()`) can be passed as well.</dd>
		
		<dd><code>operator</code> - The operator to use for the constraint (i.e. "=", "<", ">=", etc.).  A value can be passed as the `operator` and the `value` left null as a shortcut for equals (e.g. where( "column", 1 ) == where( "column", "=", 1 ) ).</dd>
		
		<dd><code>value</code> - The value with which to constrain the column.  An expression (`builder.raw()`) can be passed as well.</dd>
		
		<dd><code>combinator</code></dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="implode()"><!-- --></a>
	<h3>implode</h3>
	
	<kbd>public string <strong>implode</strong>(string column, [string glue=''], [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Get all the values of a column in a query and return it as a single string glued together.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column from which to extract the values.</dd>
		
		<dd><code>glue</code> - The string to use when joining the columns together.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>string</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="insert()"><!-- --></a>
	<h3>insert</h3>
	
	<kbd>public any <strong>insert</strong>(any values, [struct options='[runtime expression]'], [boolean toSql='false'])</kbd>
	
	<br><br>

	
		<p>Inserts a single struct or an array of structs in to a table.
This call must come after setting the query's table using `from` or `table`.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>values</code> - A struct or array of structs to insert in to the table.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		<dd><code>toSql</code> - If true, returns the raw sql string instead of running the query.  Useful for debugging. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>query</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="isInvalidCombinator()"><!-- --></a>
	<h3>isInvalidCombinator</h3>
	
	<kbd>private boolean <strong>isInvalidCombinator</strong>(string combinator)</kbd>
	
	<br><br>

	
		<p>Checks if a combinator is an invalid sql combinator (according to qb).</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>combinator</code> - The combinator to check.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>boolean</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="isInvalidOperator()"><!-- --></a>
	<h3>isInvalidOperator</h3>
	
	<kbd>private boolean <strong>isInvalidOperator</strong>(string operator)</kbd>
	
	<br><br>

	
		<p>Checks if an operator is an invalid sql operator (according to qb).</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>operator</code> - The operator to check.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>boolean</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="isVariadicFunction()"><!-- --></a>
	<h3>isVariadicFunction</h3>
	
	<kbd>private boolean <strong>isVariadicFunction</strong>(struct args)</kbd>
	
	<br><br>

	
		<p>Returns true if the arguments passed constitute a variadic function.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>args</code> - The arguments of another function.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>boolean</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="join()"><!-- --></a>
	<h3>join</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>join</strong>(string table, any first, [string operator='='], [string second], [string type='inner'], [boolean where='false'])</kbd>
	
	<br><br>

	
		<p>Adds an INNER JOIN to another table.
For simple joins, this specifies a column on which to join the two tables.
For complex joins, a closure can be passed to `first`.
This allows multiple `on` and `where` conditions to be applied to the join.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>table</code> - The table to join to the query.</dd>
		
		<dd><code>first</code> - The first column in the join's `on` statement. This alternatively can be a closure that will be passed a JoinClause for complex joins. Passing a closure ignores all subsequent parameters.</dd>
		
		<dd><code>operator</code> - The boolean operator for the join clause. Default: "=".</dd>
		
		<dd><code>second</code> - The second column in the join's `on` statement.</dd>
		
		<dd><code>type</code> - The type of the join. Default: "inner".  Passing this as an argument is discouraged for readability.  Use the dedicated methods like `leftJoin` and `rightJoin` where possible.</dd>
		
		<dd><code>where</code> - Sets if the value of `second` should be interpreted as a column or a value.  Passing this as an argument is discouraged.  Use the dedicated `joinWhere` or a join closure where possible.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="joinWhere()"><!-- --></a>
	<h3>joinWhere</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>joinWhere</strong>(string table, any first, [string operator], [string second], [string type='inner'])</kbd>
	
	<br><br>

	
		<p>Adds a JOIN to another table based on a `WHERE` clause instead of an `ON` clause.
`where` clauses introduce parameters and parameter bindings
whereas `on` clauses join between columns and don't need parameter bindings.
For simple joins, this specifies a column on which to join the two tables.
For complex joins, a closure can be passed to `first`.
This allows multiple `on` and `where` conditions to be applied to the join.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>table</code> - The table to join to the query.</dd>
		
		<dd><code>first</code> - The first column in the join's `on` statement. This alternatively can be a closure that will be passed a JoinClause for complex joins. Passing a closure ignores all subsequent parameters.</dd>
		
		<dd><code>operator</code> - The boolean operator for the join clause. Default: "=".</dd>
		
		<dd><code>second</code> - The second column in the join's `on` statement.</dd>
		
		<dd><code>type</code> - The type of the join. Default: "inner".  Passing this as an argument is discouraged for readability.  Use the dedicated methods like `leftJoin` and `rightJoin` where possible.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="leftJoin()"><!-- --></a>
	<h3>leftJoin</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>leftJoin</strong>(string table, [string first], [string operator], [string second], [boolean where])</kbd>
	
	<br><br>

	
		<p>Adds a LEFT JOIN to another table.
For simple joins, this specifies a column on which to join the two tables.
For complex joins, a closure can be passed to `first`.
This allows multiple `on` and `where` conditions to be applied to the join.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>table</code> - The table to join to the query.</dd>
		
		<dd><code>first</code> - The first column in the join's `on` statement. This alternatively can be a closure that will be passed a JoinClause for complex joins. Passing a closure ignores all subsequent parameters.</dd>
		
		<dd><code>operator</code> - The boolean operator for the join clause. Default: "=".</dd>
		
		<dd><code>second</code> - The second column in the join's `on` statement.</dd>
		
		<dd><code>where</code> - Sets if the value of `second` should be interpreted as a column or a value.  Passing this as an argument is discouraged.  Use the dedicated `joinWhere` or a join closure where possible.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="limit()"><!-- --></a>
	<h3>limit</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>limit</strong>(numeric value)</kbd>
	
	<br><br>

	
		<p>Sets the limit value for the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>value</code> - The limit value for the query.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="max()"><!-- --></a>
	<h3>max</h3>
	
	<kbd>public any <strong>max</strong>(string column, [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Return the max of a column from a query.
The original query is unaltered by this operation.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The column on which to find the max.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="min()"><!-- --></a>
	<h3>min</h3>
	
	<kbd>public any <strong>min</strong>(string column, [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Return the min of a column from a query.
The original query is unaltered by this operation.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The column on which to find the min.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="newQuery()"><!-- --></a>
	<h3>newQuery</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>newQuery</strong>()</kbd>
	
	<br><br>

	
		<p>Creates a new query using the same Grammar and QueryUtils.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="normalizeListArgumentsToArray()"><!-- --></a>
	<h3>normalizeListArgumentsToArray</h3>
	
	<kbd>private array <strong>normalizeListArgumentsToArray</strong>(string list)</kbd>
	
	<br><br>

	
		<p>Converts a list of arguments to an array.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>list</code> - A list containing multiple arguments.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>array</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="normalizeToArray()"><!-- --></a>
	<h3>normalizeToArray</h3>
	
	<kbd>private array <strong>normalizeToArray</strong>()</kbd>
	
	<br><br>

	
		<p>Converts the arguments passed in to it into an array.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>array</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="normalizeVariadicArgumentsToArray()"><!-- --></a>
	<h3>normalizeVariadicArgumentsToArray</h3>
	
	<kbd>private array <strong>normalizeVariadicArgumentsToArray</strong>(struct args)</kbd>
	
	<br><br>

	
		<p>Converts a variadic list of arguments to an array.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>args</code> - The arguments of another function.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>array</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="offset()"><!-- --></a>
	<h3>offset</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>offset</strong>(numeric value)</kbd>
	
	<br><br>

	
		<p>Sets the offset value for the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>value</code> - The offset value for the query.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="onMissingMethod()"><!-- --></a>
	<h3>onMissingMethod</h3>
	
	<kbd>public any <strong>onMissingMethod</strong>([string missingMethodName], [struct missingMethodArguments])</kbd>
	
	<br><br>

	
		<p>onMissingMethod serves the following purpose for Builder:
Magic `where` methods. If a method starts with `where` or `orWhere`
but doesn't match any other methods, Builder assumes that what
comes after is the column name to constrain.
All the other arguments to `where` are shifted accordingly.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>missingMethodName</code></dd>
		
		<dd><code>missingMethodArguments</code></dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orderBy()"><!-- --></a>
	<h3>orderBy</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orderBy</strong>(any column, [string direction='asc'])</kbd>
	
	<br><br>

	
		<p>Add an order by clause to the query.  To order by multiple columns, call `orderBy` multiple times.
The order in which `orderBy` is called matters and is the order it appears in the SQL.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column to order by. An expression (`builder.raw()`) can be passed as well.</dd>
		
		<dd><code>direction</code> - The direction by which to order the query.  Accepts "asc" OR "desc". Default: "asc".</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhere()"><!-- --></a>
	<h3>orWhere</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhere</strong>([any column], [any operator], [any value])</kbd>
	
	<br><br>

	
		<p>Adds an OR WHERE clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query. A closure can be passed to begin a nested where statement.</dd>
		
		<dd><code>operator</code> - The operator to use for the constraint (i.e. "=", "<", ">=", etc.).  A value can be passed as the `operator` and the `value` left null as a shortcut for equals (e.g. where( "column", 1 ) == where( "column", "=", 1 ) ).</dd>
		
		<dd><code>value</code> - The value with which to constrain the column.  An expression (`builder.raw()`) can be passed as the value as well.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereBetween()"><!-- --></a>
	<h3>orWhereBetween</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereBetween</strong>([any column], [any start], [any end], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds a OR WHERE BETWEEN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query.</dd>
		
		<dd><code>start</code> - The beginning value of the BETWEEN statement.</dd>
		
		<dd><code>end</code> - The end value of the BETWEEN statement.</dd>
		
		<dd><code>negate</code> - False for BETWEEN, True for NOT BETWEEN. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereColumn()"><!-- --></a>
	<h3>orWhereColumn</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereColumn</strong>(any first, [any operator], [any second])</kbd>
	
	<br><br>

	
		<p>Adds a OR WHERE clause to the query comparing two columns</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>first</code> - The name of the first column to compare.</dd>
		
		<dd><code>operator</code> - The operator to use for the constraint (i.e. "=", "<", ">=", etc.).  A value can be passed as the `operator` and the `second` left null as a shortcut for equals (e.g. whereColumn( "columnA", "columnB" ) == where( "column", "=", "columnB" ) ).</dd>
		
		<dd><code>second</code> - The name of the second column to compare.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereExists()"><!-- --></a>
	<h3>orWhereExists</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereExists</strong>([any callback], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds an OR WHERE EXISTS clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>callback</code> - A callback to specify the query for the EXISTS clause.  It will be passed a query as the only argument.</dd>
		
		<dd><code>negate</code> - False for EXISTS, True for NOT EXISTS. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereIn()"><!-- --></a>
	<h3>orWhereIn</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereIn</strong>([any column], [any values], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds an OR WHERE IN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query. A closure can be passed to begin a nested where statement.</dd>
		
		<dd><code>values</code> - The values with which to constrain the column. An expression (`builder.raw()`) can be passed as any of the values as well.</dd>
		
		<dd><code>negate</code> - False for IN, True for NOT IN. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereNotBetween()"><!-- --></a>
	<h3>orWhereNotBetween</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereNotBetween</strong>([any column], [any start], [any end], [any combinator])</kbd>
	
	<br><br>

	
		<p>Adds an OR WHERE NOT BETWEEN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query.</dd>
		
		<dd><code>start</code> - The beginning value of the BETWEEN statement.</dd>
		
		<dd><code>end</code> - The end value of the BETWEEN statement.</dd>
		
		<dd><code>combinator</code></dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereNotExists()"><!-- --></a>
	<h3>orWhereNotExists</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereNotExists</strong>([any callback])</kbd>
	
	<br><br>

	
		<p>Adds a OR WHERE NOT EXISTS clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>callback</code> - A callback to specify the query for the EXISTS clause.  It will be passed a query as the only argument.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereNotIn()"><!-- --></a>
	<h3>orWhereNotIn</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereNotIn</strong>([any column], [any values])</kbd>
	
	<br><br>

	
		<p>Adds an OR WHERE NOT IN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query. A closure can be passed to begin a nested where statement.</dd>
		
		<dd><code>values</code> - The values with which to constrain the column. An expression (`builder.raw()`) can be passed as any of the values as well.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereNotNull()"><!-- --></a>
	<h3>orWhereNotNull</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereNotNull</strong>([any column])</kbd>
	
	<br><br>

	
		<p>Adds an OR WHERE NOT NULL clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column to check if it is NULL.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereNull()"><!-- --></a>
	<h3>orWhereNull</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereNull</strong>([any column], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds an OR WHERE NULL clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column to check if it is NULL.</dd>
		
		<dd><code>negate</code> - False for NULL, True for NOT NULL. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="orWhereRaw()"><!-- --></a>
	<h3>orWhereRaw</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>orWhereRaw</strong>(string sql, [array whereBindings='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Adds a raw SQL statement to the WHERE clauses with an OR combinator.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>sql</code> - The raw SQL to add to the query.</dd>
		
		<dd><code>whereBindings</code> - Any bindings needed for the raw SQL. Default: [].</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="raw()"><!-- --></a>
	<h3>raw</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Expression.html" title="class in qb.models.Query">Expression</a> <strong>raw</strong>(string sql)</kbd>
	
	<br><br>

	
		<p>Wrap up any sql in an Expression.
Expressions are not parameterized or escaped in any way.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>sql</code> - The raw sql to wrap up in an Expression.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Expression</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="rightJoin()"><!-- --></a>
	<h3>rightJoin</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>rightJoin</strong>(string table, [string first], [string operator], [string second], [boolean where])</kbd>
	
	<br><br>

	
		<p>Adds a RIGHT JOIN to another table.
For simple joins, this specifies a column on which to join the two tables.
For complex joins, a closure can be passed to `first`.
This allows multiple `on` and `where` conditions to be applied to the join.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>table</code> - The table to join to the query.</dd>
		
		<dd><code>first</code> - The first column in the join's `on` statement. This alternatively can be a closure that will be passed a JoinClause for complex joins. Passing a closure ignores all subsequent parameters.</dd>
		
		<dd><code>operator</code> - The boolean operator for the join clause. Default: "=".</dd>
		
		<dd><code>second</code> - The second column in the join's `on` statement.</dd>
		
		<dd><code>where</code> - Sets if the value of `second` should be interpreted as a column or a value.  Passing this as an argument is discouraged.  Use the dedicated `joinWhere` or a join closure where possible.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="run()"><!-- --></a>
	<h3>run</h3>
	
	<kbd>private any <strong>run</strong>(string sql, [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Execute a query and convert it to the proper return format.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>sql</code> - The sql string to execute.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="runQuery()"><!-- --></a>
	<h3>runQuery</h3>
	
	<kbd>private any <strong>runQuery</strong>(string sql, [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Run a query through the specified grammar then clear all bindings.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>sql</code> - The sql string to execute.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="select()"><!-- --></a>
	<h3>select</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>select</strong>([any columns='*'])</kbd>
	
	<br><br>

	
		<p>Sets a selection of columns to select from the query.
Individual columns can contain fully-qualified names (i.e. "some_table.some_column"),
fully-qualified names with table aliases (i.e. "alias.some_column"),
and even set column aliases themselves (i.e. "some_column AS c")
Each value will be wrapped correctly, according to the database grammar being used.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>columns</code> - A single column, a list or columns (comma-separated), or an array of columns. Default: "*".</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="selectRaw()"><!-- --></a>
	<h3>selectRaw</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>selectRaw</strong>(any expression)</kbd>
	
	<br><br>

	
		<p>Adds a Expression to the already selected columns.
Individual columns can contain fully-qualified names (i.e. "some_table.some_column"),
fully-qualified names with table aliases (i.e. "alias.some_column"),
and even set column aliases themselves (i.e. "some_column AS c")
Each value will be wrapped correctly, according to the database grammar being used.
If no columns have been set, this column will overwrite the global "*".</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>expression</code> - A raw query expression to add to the query.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="setAggregate()"><!-- --></a>
	<h3>setAggregate</h3>
	
	<kbd>public any <strong>setAggregate</strong>(struct aggregate)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>aggregate</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setColumns()"><!-- --></a>
	<h3>setColumns</h3>
	
	<kbd>public any <strong>setColumns</strong>(array columns)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>columns</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setDefaultValues()"><!-- --></a>
	<h3>setDefaultValues</h3>
	
	<kbd>private void <strong>setDefaultValues</strong>()</kbd>
	
	<br><br>

	
		<p>Sets up the default values for a new builder instance.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>void</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="setDistinct()"><!-- --></a>
	<h3>setDistinct</h3>
	
	<kbd>public any <strong>setDistinct</strong>(boolean distinct)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>distinct</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setFrom()"><!-- --></a>
	<h3>setFrom</h3>
	
	<kbd>public any <strong>setFrom</strong>(string from)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>from</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setGrammar()"><!-- --></a>
	<h3>setGrammar</h3>
	
	<kbd>public any <strong>setGrammar</strong>(any grammar)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>grammar</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setGroups()"><!-- --></a>
	<h3>setGroups</h3>
	
	<kbd>public any <strong>setGroups</strong>(array groups)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>groups</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setHavings()"><!-- --></a>
	<h3>setHavings</h3>
	
	<kbd>public any <strong>setHavings</strong>(array havings)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>havings</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setJoins()"><!-- --></a>
	<h3>setJoins</h3>
	
	<kbd>public any <strong>setJoins</strong>(array joins)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>joins</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setLimitValue()"><!-- --></a>
	<h3>setLimitValue</h3>
	
	<kbd>public any <strong>setLimitValue</strong>(numeric limitValue)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>limitValue</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setOffsetValue()"><!-- --></a>
	<h3>setOffsetValue</h3>
	
	<kbd>public any <strong>setOffsetValue</strong>(numeric offsetValue)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>offsetValue</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setOrders()"><!-- --></a>
	<h3>setOrders</h3>
	
	<kbd>public any <strong>setOrders</strong>(array orders)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>orders</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setReturnFormat()"><!-- --></a>
	<h3>setReturnFormat</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>setReturnFormat</strong>(any format)</kbd>
	
	<br><br>

	
		<p>Sets the return format for the query.
The return format can be a simple string like "query" to return queries or "array" to return an array of structs.
Alternative, the return format can be a closure.  The closure is passed the query as the only argument.  The result of the closure is returned as the result of the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>format</code> - "query", "array", or a closure.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="setUtils()"><!-- --></a>
	<h3>setUtils</h3>
	
	<kbd>public any <strong>setUtils</strong>(any utils)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>utils</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="setWheres()"><!-- --></a>
	<h3>setWheres</h3>
	
	<kbd>public any <strong>setWheres</strong>(array wheres)</kbd>
	
	<br><br>

	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>wheres</code></dd>
		
		</dl>
	

	

	</dl>
	<hr>

	
	<a name="sum()"><!-- --></a>
	<h3>sum</h3>
	
	<kbd>public any <strong>sum</strong>(string column, [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Return the sum of a column from a query.
The original query is unaltered by this operation.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The column on which to find the sum.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="table()"><!-- --></a>
	<h3>table</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>table</strong>(string table)</kbd>
	
	<br><br>

	
		<p>Sets the FROM table of the query.
Alias for `from`</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>table</code> - The name of the table to from which the query is based.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="take()"><!-- --></a>
	<h3>take</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>take</strong>(numeric value)</kbd>
	
	<br><br>

	
		<p>Sets the limit value for the query.
Alias for `limit`.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>value</code> - The limit value for the query.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="tap()"><!-- --></a>
	<h3>tap</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>tap</strong>(any callback)</kbd>
	
	<br><br>

	
		<p>Tap takes a callback and calls that callback with a copy of the current query.
The results of calling the callback are ignored.  The query is returned unmodified.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>callback</code> - A callback to execute with the current query.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="toSQL()"><!-- --></a>
	<h3>toSQL</h3>
	
	<kbd>public string <strong>toSQL</strong>()</kbd>
	
	<br><br>

	
		<p>Returns the Builder compiled to grammar-specific sql.</p>
	

	
		
		
	

	
	

	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>string</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="update()"><!-- --></a>
	<h3>update</h3>
	
	<kbd>public any <strong>update</strong>(struct values, [struct options='[runtime expression]'], [boolean toSql='false'])</kbd>
	
	<br><br>

	
		<p>Updates a table with a struct of column and value pairs.
This call must come after setting the query's table using `from` or `table`.
Any constraining of the update query should be done using the appropriate WHERE statement before calling `update`.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>values</code> - A struct of column and value pairs to update.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		<dd><code>toSql</code> - If true, returns the raw sql string instead of running the query.  Useful for debugging. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>query</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="updateOrInsert()"><!-- --></a>
	<h3>updateOrInsert</h3>
	
	<kbd>public any <strong>updateOrInsert</strong>(struct values, [struct options='[runtime expression]'], [boolean toSql='false'])</kbd>
	
	<br><br>

	
		<p>If the query returns any rows, updates the first result found. Otherwise, inserts the values into the table.
This call must come after setting the query's table using `from` or `table`.
Any constraining of the query should be done using the appropriate WHERE statement before calling `updateOrInsert`.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>values</code> - A struct of column and value pairs to update.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		<dd><code>toSql</code> - If true, returns the raw sql string instead of running the query.  Useful for debugging. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>query</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="value()"><!-- --></a>
	<h3>value</h3>
	
	<kbd>public any <strong>value</strong>(string column, [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Returns the first value of a column in a query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The column for which to retrieve the value.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="values()"><!-- --></a>
	<h3>values</h3>
	
	<kbd>public array <strong>values</strong>(string column, [struct options='[runtime expression]'])</kbd>
	
	<br><br>

	
		<p>Returns an array of values for a column in a query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The column for which to retrieve the values.</dd>
		
		<dd><code>options</code> - Any options to pass to `queryExecute`. Default: {}.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="when()"><!-- --></a>
	<h3>when</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>when</strong>(boolean condition, [any onTrue], [any onFalse])</kbd>
	
	<br><br>

	
		<p>When is a useful helper method that introduces if / else control flow without breaking chainability.
When the `condition` is true, the `onTrue` callback is triggered.  If the `condition` is false and an `onFalse` callback is passed, it is triggered.  Otherwise, the query is returned unmodified.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>condition</code> - A boolean condition that if true will trigger the `onTrue` callback. If not true, the `onFalse` callback will trigger if it was passed. Otherwise, the query is returned unmodified.</dd>
		
		<dd><code>onTrue</code> - A closure that will be triggered if the `condition` is true.</dd>
		
		<dd><code>onFalse</code></dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="where()"><!-- --></a>
	<h3>where</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>where</strong>([any column], [any operator], [any value], [string combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query. A closure can be passed to begin a nested where statement.</dd>
		
		<dd><code>operator</code> - The operator to use for the constraint (i.e. "=", "<", ">=", etc.).  A value can be passed as the `operator` and the `value` left null as a shortcut for equals (e.g. where( "column", 1 ) == where( "column", "=", 1 ) ).</dd>
		
		<dd><code>value</code> - The value with which to constrain the column.  An expression (`builder.raw()`) can be passed as well.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereBetween()"><!-- --></a>
	<h3>whereBetween</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereBetween</strong>([any column], [any start], [any end], [any combinator='and'], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE BETWEEN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query.</dd>
		
		<dd><code>start</code> - The beginning value of the BETWEEN statement.</dd>
		
		<dd><code>end</code> - The end value of the BETWEEN statement.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		<dd><code>negate</code> - False for BETWEEN, True for NOT BETWEEN. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereColumn()"><!-- --></a>
	<h3>whereColumn</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereColumn</strong>(any first, [any operator], [any second], [string combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE clause to the query comparing two columns</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>first</code> - The name of the first column to compare.</dd>
		
		<dd><code>operator</code> - The operator to use for the constraint (i.e. "=", "<", ">=", etc.).  A value can be passed as the `operator` and the `second` left null as a shortcut for equals (e.g. whereColumn( "columnA", "columnB" ) == where( "column", "=", "columnB" ) ).</dd>
		
		<dd><code>second</code> - The name of the second column to compare.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereExists()"><!-- --></a>
	<h3>whereExists</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereExists</strong>([any callback], [any combinator='and'], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE EXISTS clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>callback</code> - A callback to specify the query for the EXISTS clause.  It will be passed a query as the only argument.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		<dd><code>negate</code> - False for EXISTS, True for NOT EXISTS. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereIn()"><!-- --></a>
	<h3>whereIn</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereIn</strong>([any column], [any values], [any combinator='and'], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE IN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query. A closure can be passed to begin a nested where statement.</dd>
		
		<dd><code>values</code> - The values with which to constrain the column. An expression (`builder.raw()`) can be passed as any of the values as well.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		<dd><code>negate</code> - False for IN, True for NOT IN. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereInSub()"><!-- --></a>
	<h3>whereInSub</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereInSub</strong>([any column], [any callback], [any combinator='and'], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE IN clause to the query using a subselect.  To call this using the public api, pass a closure to `whereIn` as the second argument (`values`).</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query.</dd>
		
		<dd><code>callback</code> - A closure that will contain the subquery with which to constain this clause.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		<dd><code>negate</code> - False for IN, True for NOT IN. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereNested()"><!-- --></a>
	<h3>whereNested</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereNested</strong>(any callback, [any combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a nested where statement to the query. (Basically adding parenthesis to the statments in the nested section.)
The public api to create a nested WHERE statement is by passing a callback as the first parameter to `where`.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>callback</code> - The callback that contains the nested query logic.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereNotBetween()"><!-- --></a>
	<h3>whereNotBetween</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereNotBetween</strong>([any column], [any start], [any end], [any combinator])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE NOT BETWEEN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query.</dd>
		
		<dd><code>start</code> - The beginning value of the BETWEEN statement.</dd>
		
		<dd><code>end</code> - The end value of the BETWEEN statement.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereNotExists()"><!-- --></a>
	<h3>whereNotExists</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereNotExists</strong>([any callback], [any combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE NOT EXISTS clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>callback</code> - A callback to specify the query for the EXISTS clause.  It will be passed a query as the only argument.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereNotIn()"><!-- --></a>
	<h3>whereNotIn</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereNotIn</strong>([any column], [any values], [any combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE NOT IN clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query. A closure can be passed to begin a nested where statement.</dd>
		
		<dd><code>values</code> - The values with which to constrain the column. An expression (`builder.raw()`) can be passed as any of the values as well.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereNotNull()"><!-- --></a>
	<h3>whereNotNull</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereNotNull</strong>([any column], [any combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE NOT NULL clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column to check if it is NULL.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereNull()"><!-- --></a>
	<h3>whereNull</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereNull</strong>([any column], [any combinator='and'], [any negate='false'])</kbd>
	
	<br><br>

	
		<p>Adds a WHERE NULL clause to the query.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column to check if it is NULL.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		<dd><code>negate</code> - False for NULL, True for NOT NULL. Default: false.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereRaw()"><!-- --></a>
	<h3>whereRaw</h3>
	
	<kbd>public <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereRaw</strong>(string sql, [array whereBindings='[runtime expression]'], [string combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a raw SQL statement to the WHERE clauses.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>sql</code> - The raw SQL to add to the query.</dd>
		
		<dd><code>whereBindings</code> - Any bindings needed for the raw SQL. Default: [].</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="whereSub()"><!-- --></a>
	<h3>whereSub</h3>
	
	<kbd>private <a href="../../../qb/models/Query/Builder.html" title="class in qb.models.Query">Builder</a> <strong>whereSub</strong>([any column], [any operator], [any callback], [any combinator='and'])</kbd>
	
	<br><br>

	
		<p>Adds a where clause where the value is a subquery.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>column</code> - The name of the column with which to constrain the query.</dd>
		
		<dd><code>operator</code> - The operator to use for the constraint (i.e. "=", "<", ">=", etc.).</dd>
		
		<dd><code>callback</code> - The closure that defines the subquery. A new query will be passed to the closure as the only argument.</dd>
		
		<dd><code>combinator</code> - The boolean combinator for the clause (e.g. "and" or "or"). Default: "and"</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>qb.models.Query.Builder</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="withAggregate()"><!-- --></a>
	<h3>withAggregate</h3>
	
	<kbd>private any <strong>withAggregate</strong>(struct aggregate, any callback)</kbd>
	
	<br><br>

	
		<p>Runs the code inside the callback with the given aggregate in place and then sets the aggregate back to its original value.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>aggregate</code> - he aggregate option and column to execute. (e.g. `{ type = "count", column = "*" }`).</dd>
		
		<dd><code>callback</code> - The code to execute with the given aggregate.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="withColumns()"><!-- --></a>
	<h3>withColumns</h3>
	
	<kbd>private any <strong>withColumns</strong>(any columns, any callback)</kbd>
	
	<br><br>

	
		<p>Runs the code inside the callback with the given columns selected and then sets the columns back to its original value.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>columns</code> - A single column, a list or columns (comma-separated), or an array of columns.</dd>
		
		<dd><code>callback</code> - The code to execute with the given columns.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>

	
	<a name="withReturnFormat()"><!-- --></a>
	<h3>withReturnFormat</h3>
	
	<kbd>private any <strong>withReturnFormat</strong>(any returnFormat, any callback)</kbd>
	
	<br><br>

	
		<p>Runs the code inside the callback with the return format specified and then sets the return format back to its original value.</p>
	

	
		
		
	

	
	

	
		<dl>
		<dt><strong>Parameters:</strong></dt>
		
		<dd><code>returnFormat</code> - "query", "array", or a closure.</dd>
		
		<dd><code>callback</code> - The code to execute with the given return format.</dd>
		
		</dl>
	

	
		<dl>
			<dt><strong>Returns:</strong></dt>
			<dd>any</dd>
		</dl>
	

	</dl>
	<hr>




</body>
</html>

